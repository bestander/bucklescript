type array_buffer
type 'a array_like
    
#define TYPED_ARRAY(elt) \
  (* [elt] *) \
  type 'a typed_array \
  type t = elt typed_array \
  external unsafe_get : t -> int -> elt  = "" [@@bs.get_index] \
  external unsafe_set : t -> int -> elt -> unit = "" [@@bs.set_index] \
  external buffer : t -> array_buffer = "" [@@bs.get] \
  external byteLength : t -> int = "" [@@bs.get] \
  external byteOffset : t -> int = "" [@@bs.get] \
  external setArray : elt array -> unit = "set" [@@bs.send.pipe: t] \
  external setArrayOffset : elt array -> int -> unit = "set" [@@bs.send.pipe: t] \
  (* There's also an overload for typed arrays, but don't know how to model that without subtyping *) \
  external length : t -> int = "" [@@bs.get] \
  (* Mutator functions  *) \
  external copyWithin : to_:int -> t = "" [@@bs.send.pipe: t] \
  external copyWithinFrom : to_:int -> from:int -> t = "copyWithin" [@@bs.send.pipe: t] \
  external copyWithinFromRange : to_:int -> start:int -> end_:int -> t = "copyWithin" [@@bs.send.pipe: t] \
  external fillInPlace : elt -> t = "fill" [@@bs.send.pipe: t] \
  external fillFromInPlace : elt -> from:int -> t = "fill" [@@bs.send.pipe: t] \
  external fillRangeInPlace : elt -> start:int -> end_:int -> t = "fill" [@@bs.send.pipe: t] \
  external reverseInPlace : t = "reverse" [@@bs.send.pipe: t] \
  external sortInPlace : t = "sort" [@@bs.send.pipe: t] \
  external sortInPlaceWith : (elt -> elt -> int [@bs]) -> t = "sort" [@@bs.send.pipe: t] \
  (* Accessor functions  *) \
  external includes : elt -> Js.boolean = "" [@@bs.send.pipe: t] (** ES2016 *) \
  external indexOf : elt  -> int = "" [@@bs.send.pipe: t] \
  external indexOfFrom : elt -> from:int -> int = "indexOf" [@@bs.send.pipe: t] \
  external join : string = "" [@@bs.send.pipe: t] \
  external joinWith : string -> string = "join" [@@bs.send.pipe: t] \
  external lastIndexOf : elt -> int = "" [@@bs.send.pipe: t] \
  external lastIndexOfFrom : elt -> from:int -> int = "lastIndexOf" [@@bs.send.pipe: t] \
  external slice : start:int -> end_:int -> t = "" [@@bs.send.pipe: t] \
  external copy : t = "slice" [@@bs.send.pipe: t] \
  external sliceFrom : int -> t = "slice" [@@bs.send.pipe: t] \
  external toString : string = "" [@@bs.send.pipe: t] \
  external toLocaleString : string = "" [@@bs.send.pipe: t] \
  external every : (elt  -> Js.boolean [@bs]) -> Js.boolean = "" [@@bs.send.pipe: t] \
  external everyi : (elt -> int -> Js.boolean [@bs]) -> Js.boolean = "every" [@@bs.send.pipe: t] \
  (** should we use [bool] or [boolan] seems they are intechangeable here *) \
  external filter : (elt -> bool [@bs]) -> t = "" [@@bs.send.pipe: t] \
  external filteri : (elt -> int  -> Js.boolean[@bs]) -> t = "filter" [@@bs.send.pipe: t] \
  external find : (elt -> bool [@bs]) -> elt Js.undefined = "" [@@bs.send.pipe: t] \
  external findi : (elt -> int -> bool [@bs]) -> elt Js.undefined  = "find" [@@bs.send.pipe: t] \
  external findIndex : (elt -> bool [@bs]) -> int = "" [@@bs.send.pipe: t] \
  external findIndexi : (elt -> int -> bool [@bs]) -> int = "findIndex" [@@bs.send.pipe: t] \
  external forEach : (elt -> unit [@bs]) -> unit = "" [@@bs.send.pipe: t] \
  external forEachi : (elt -> int -> unit [@bs]) -> unit  = "forEach" [@@bs.send.pipe: t] \
  external map : (elt  -> 'b [@bs]) -> 'b typed_array = "" [@@bs.send.pipe: t] \
  external mapi : (elt -> int ->  'b [@bs]) -> 'b typed_array = "map" [@@bs.send.pipe: t] \
  external reduce :  ('b -> elt  -> 'b [@bs]) -> 'b -> 'b = "" [@@bs.send.pipe: t] \
  external reducei : ('b -> elt -> int -> 'b [@bs]) -> 'b -> 'b = "reduce" [@@bs.send.pipe: t] \
  external reduceRight :  ('b -> elt  -> 'b [@bs]) -> 'b -> 'b = "" [@@bs.send.pipe: t] \
  external reduceRighti : ('b -> elt -> int -> 'b [@bs]) -> 'b -> 'b = "reduceRight" [@@bs.send.pipe: t] \
  external some : (elt  -> Js.boolean [@bs]) -> Js.boolean = "" [@@bs.send.pipe: t] \
  external somei : (elt  -> int -> Js.boolean [@bs]) -> Js.boolean = "some" [@@bs.send.pipe: t]

TYPED_ARRAY(int)

  (* Iteration functions
  *)
  (* commented out until bs has a plan for iterators
  external entries : (int * elt) array_iter = "" [@@bs.send.pipe: t]
  *)

  (* commented out until bs has a plan for iterators
  external keys : int array_iter = "" [@@bs.send.pipe: t]
  *)
